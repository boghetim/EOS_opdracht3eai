/*
 * Copyright (C) 2017 - 2019 Xilinx, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 */

#include <sleep.h>
#include "netif/xadapter.h"
#include "platform_config.h"
#include "xil_printf.h"
#include "lwip/init.h"
#include "lwip/inet.h"

//AUDIO
#include <stdio.h>
#include "audio.h"
#include "sleep.h"
#include "xiicps.h"
#include "xparameters.h"
#include "xgpio.h"
#include "xgpiops.h"
//include math.h for sinefucntions
#include "math.h"
typedef short		Xint16;
typedef long		Xint32;
//gpio0
#define RGB_CHANNEL 1
#define SW_CHANNEL 2
#define RGB 0xFF
//gpio1
#define LED_CHANNEL 2
#define BTN_CHANNEL 1
#define LEDS 0x0F
unsigned char IicConfig(unsigned int DeviceIdPS);
void AudioPllConfig();
void AudioWriteToReg(unsigned char u8RegAddr, unsigned char u8Data);
void AudioConfigureJacks();
void LineinLineoutConfig();
void audio_test();
//Function prototypes for synthesizer
void audio_synthesizer();
XIicPs Iic;
XGpio Gpio0;
XGpio Gpio1;


#if LWIP_DHCP==1
#include "lwip/dhcp.h"
extern volatile int dhcp_timoutcntr;
err_t dhcp_start(struct netif *netif);
#endif

static int complete_nw_thread;

void print_app_header();
void start_application();

#define THREAD_STACKSIZE 1024

#define DEFAULT_IP_ADDRESS "192.168.1.10"
#define DEFAULT_IP_MASK "255.255.255.0"
#define DEFAULT_GW_ADDRESS "192.168.1.1"

struct netif server_netif;
#define QUEUE_SIZE 10

// Define the queue handle globally
QueueHandle_t xQueue;

static void print_ip(char *msg, ip_addr_t *ip)
{
	xil_printf(msg);
	xil_printf("%d.%d.%d.%d\n\r", ip4_addr1(ip), ip4_addr2(ip),
				ip4_addr3(ip), ip4_addr4(ip));
}

static void print_ip_settings(ip_addr_t *ip, ip_addr_t *mask, ip_addr_t *gw)
{
	print_ip("Board IP:       ", ip);
	print_ip("Netmask :       ", mask);
	print_ip("Gateway :       ", gw);
}

static void assign_default_ip(ip_addr_t *ip, ip_addr_t *mask, ip_addr_t *gw)
{
	int err;

	xil_printf("Configuring default IP %s \r\n", DEFAULT_IP_ADDRESS);

	err = inet_aton(DEFAULT_IP_ADDRESS, ip);
	if(!err)
		xil_printf("Invalid default IP address: %d\r\n", err);

	err = inet_aton(DEFAULT_IP_MASK, mask);
	if(!err)
		xil_printf("Invalid default IP MASK: %d\r\n", err);

	err = inet_aton(DEFAULT_GW_ADDRESS, gw);
	if(!err)
		xil_printf("Invalid default gateway address: %d\r\n", err);
}

void network_thread(void *p)
{
	int mscnt = 0;
	/* the mac address of the board. this should be unique per board */
	u8_t mac_ethernet_address[] = { 0x00, 0x0a, 0x35, 0x00, 0x01, 0x02 };

	/* Add network interface to the netif_list, and set it as default */
	if (!xemac_add(&server_netif, NULL, NULL, NULL, mac_ethernet_address,
		PLATFORM_EMAC_BASEADDR)) {
		xil_printf("Error adding N/W interface\r\n");
		return;
	}

	netif_set_default(&server_netif);

	/* specify that the network if is up */
	netif_set_up(&server_netif);

	/* start packet receive thread - required for lwIP operation */
	sys_thread_new("xemacif_input_thread",
			(void(*)(void*))xemacif_input_thread, &server_netif,
			THREAD_STACKSIZE, DEFAULT_THREAD_PRIO);

	complete_nw_thread = 1;

	dhcp_start(&server_netif);
	while (1) {
		vTaskDelay(DHCP_FINE_TIMER_MSECS / portTICK_RATE_MS);
		dhcp_fine_tmr();
		mscnt += DHCP_FINE_TIMER_MSECS;
		if (mscnt >= DHCP_COARSE_TIMER_SECS*1000) {
			dhcp_coarse_tmr();
			mscnt = 0;
		}
	}

}

int main_thread()
{

	int mscnt = 0;
	/* initialize lwIP before calling sys_thread_new */
	lwip_init();

	/* any thread using lwIP should be created using sys_thread_new */
	sys_thread_new("nw_thread", network_thread, NULL,
			THREAD_STACKSIZE, DEFAULT_THREAD_PRIO);

	while(!complete_nw_thread)
		usleep(50);

	while (1) {
		vTaskDelay(DHCP_FINE_TIMER_MSECS / portTICK_RATE_MS);
		if (server_netif.ip_addr.addr) {
			xil_printf("DHCP request success\r\n");
			break;
		}
		mscnt += DHCP_FINE_TIMER_MSECS;
		if (mscnt >= 10000) {
			xil_printf("ERROR: DHCP request timed out\r\n");
			assign_default_ip(&(server_netif.ip_addr),
						&(server_netif.netmask),
						&(server_netif.gw));
			break;
		}
	}

	print_ip_settings(&(server_netif.ip_addr), &(server_netif.netmask),
				&(server_netif.gw));
	xil_printf("\r\n");

	/* print all application headers */
	print_app_header();
	xil_printf("\r\n");

	/* start the application*/
	start_application();

	vTaskDelete(NULL);
	return 0;
}

void audio_thread(void *pvParameters)
{
    (void)pvParameters;


    	//Configure the IIC data structure
    	IicConfig(XPAR_XIICPS_0_DEVICE_ID);

    	//Init Gpio
    	XGpio_Initialize(&Gpio0, XPAR_AXI_GPIO_0_DEVICE_ID);
    	XGpio_Initialize(&Gpio1, XPAR_AXI_GPIO_1_DEVICE_ID);

    	XGpio_SetDataDirection(&Gpio0, RGB_CHANNEL, ~RGB);
    	XGpio_SetDataDirection(&Gpio1, LED_CHANNEL, ~LEDS);


    	//Configure the Audio Codec's PLL
    	AudioPllConfig();

    	//Configure the Line in and Line out ports.
    	//Call LineInLineOutConfig() for a configuration that
    	//enables the HP jack too.
    	AudioConfigureJacks();
    	LineinLineoutConfig();
        //audio_test(); /* Doesnt work? */
        audio_synthesizer();
}

int main()
{
    // Queue creation
    xQueue = xQueueCreate(QUEUE_SIZE, sizeof(char[1500]));

    // Check if the queue is successfully created
    if (xQueue == NULL) {
        // Handle queue creation failure
        xil_printf("Failed to create the queue.\n\r");
        return -1;
    }
	sys_thread_new("main_thread", (void(*)(void*))main_thread, 0,
			THREAD_STACKSIZE, DEFAULT_THREAD_PRIO);
    sys_thread_new("audio_thread", audio_thread, NULL,
            THREAD_STACKSIZE, DEFAULT_THREAD_PRIO);
    vTaskStartScheduler();
	while(1);
	return 0;
}

void audio_synthesizer(void)
{
    unsigned long u32audioData;
    unsigned long u32Temp;
    u32 sw_check;
    u32 btn_check;
    int waveform = 1;
    double amplitude = 0.5;     // Default amplitude of the waveforms (adjust as needed)
    double frequency = 500.0;   // Default frequency (adjust as needed)
    double phase = 0.0;         // Initial phase of the waveforms
    int16_t audioSample;
    char recvData[1500];

    while (1)
    {
        // Wait for RX data to become available
        do
        {
            u32Temp = Xil_In32(I2S_STATUS_REG);
        } while (u32Temp == 0);

        Xil_Out32(I2S_STATUS_REG, 0x00000001); // Clear data rdy bit

        // Get status of GPIO blocks
        sw_check = XGpio_DiscreteRead(&Gpio0, SW_CHANNEL);
        btn_check = XGpio_DiscreteRead(&Gpio1, BTN_CHANNEL);

        //xil_printf("GPIO Value button: %d\n", btn_check); /* debug print */
        //xil_printf("GPIO Value switch: %d\n",  sw_check); /* debug print */

        if (sw_check == 1) /* If else statement that turns the RGB let blue above the switch */
        {
            XGpio_DiscreteWrite(&Gpio0, RGB_CHANNEL, 1);
        }
        else if (sw_check == 2)
        {
            XGpio_DiscreteWrite(&Gpio0, RGB_CHANNEL, 8);
        }
        else
        {
            XGpio_DiscreteWrite(&Gpio0, RGB_CHANNEL, 0);
        }

        // Update LEDs based on button state
        XGpio_DiscreteWrite(&Gpio1, LED_CHANNEL, btn_check); /* is working */

        // Determine the waveform type based on the button states
        double waveformValue = 0.0;



		if(xQueueReceive(xQueue, recvData, 0) == pdTRUE)
		{
			xil_printf("Received data from queue: %s\n\r", recvData);
			sscanf(recvData, "waveform: %d ; freq: %lf ; amp: %lf ; phase: %lf",
									&(waveform), &(frequency),
									&(amplitude), &(phase));
		}

        //determine variables via UDP
        // amplitude = UDP connection AMP;

        if (btn_check == 1 && waveform == 1) // Button 1 pressed (Sine wave)
        {
        	waveformValue = amplitude * sin(2 * M_PI * frequency * phase);
        }
        else if (btn_check == 2 && waveform == 2) // Button 2 pressed (Sawtooth wave)
        {
        	waveformValue = amplitude * ((fmod(phase * frequency, 1.0) * 2.0) - 1.0);
        }
        else if (btn_check == 4 && waveform == 3) // Button 3 pressed (Triangle wave)
        {
        	waveformValue = amplitude * (1.0 - 4.0 * fabs(fmod(phase * frequency + 0.25, 1.0) - 0.5));
        }
		else if (btn_check == 8 && waveform == 4) // Button 4 pressed (Square wave)
		{
			waveformValue = (fmod(phase * frequency, 1.0) < 0.5) ? amplitude : -amplitude;
		}

        // Increment phase for the next iteration
        phase += 1.0 / 48000.0; // Assuming a sample rate of 48 kHz

        // Convert the waveform value to the appropriate data format (e.g., 16-bit signed)
        audioSample = (int16_t)(waveformValue * 32767.0);

        // Pack the audio samples into a 32-bit word for both left and right channels
        u32audioData = ((uint32_t)audioSample << 16) | ((uint32_t)audioSample & 0x0000FFFF);

        // Write the packed audio data to both left and right channels
        Xil_Out32(I2S_DATA_TX_L_REG, u32audioData);
        Xil_Out32(I2S_DATA_TX_R_REG, u32audioData);
    }
}

unsigned char IicConfig(unsigned int DeviceIdPS)
{

	XIicPs_Config *Config;
	int Status;

	//Initialize the IIC driver so that it's ready to use
	//Look up the configuration in the config table, then initialize it.
	Config = XIicPs_LookupConfig(DeviceIdPS);
	if(NULL == Config) {
		return XST_FAILURE;
	}

	Status = XIicPs_CfgInitialize(&Iic, Config, Config->BaseAddress);
	if(Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	//Set the IIC serial clock rate.
	XIicPs_SetSClk(&Iic, IIC_SCLK_RATE);

	return XST_SUCCESS;
}


/******************************************************************************
 * Configures audio codes's internal PLL. With MCLK = 8 MHz it configures the
 * PLL for a VCO frequency = 49.152 MHz, and an audio sample rate of 48 KHz.
 *
 * @param	none.
 *
 * @return	none.
 *****************************************************************************/
void AudioPllConfig() {

	unsigned char u8TxData[8], u8RxData[6];

	AudioWriteToReg(R0_CLOCK_CONTROL, 0x0E);

	// Write 6 bytes to R1
	u8TxData[0] = 0x40;
	u8TxData[1] = 0x02;
	u8TxData[2] = 0x02; // byte 1
	u8TxData[3] = 0x71; // byte 2
	u8TxData[4] = 0x02; // byte 3
	u8TxData[5] = 0x3C; // byte 4
	u8TxData[6] = 0x21; // byte 5
	u8TxData[7] = 0x01; // byte 6


	XIicPs_MasterSendPolled(&Iic, u8TxData, 8, (IIC_SLAVE_ADDR >> 1));
	while(XIicPs_BusIsBusy(&Iic));

	// Poll PLL Lock bit
	u8TxData[0] = 0x40;
	u8TxData[1] = 0x02;

	do {
		XIicPs_MasterSendPolled(&Iic, u8TxData, 2, (IIC_SLAVE_ADDR >> 1));
		while(XIicPs_BusIsBusy(&Iic));
		XIicPs_MasterRecvPolled(&Iic, u8RxData, 6, (IIC_SLAVE_ADDR >> 1));
		while(XIicPs_BusIsBusy(&Iic));
	}
	while((u8RxData[5] & 0x02) == 0);

	AudioWriteToReg(R0_CLOCK_CONTROL, 0x0F);//COREN
}

/******************************************************************************
 * Function to write one byte (8-bits) to one of the registers from the audio
 * controller.
 *
 * @param	u8RegAddr is the LSB part of the register address (0x40xx).
 * @param	u8Data is the data byte to write.
 *
 * @return	none.
 *****************************************************************************/
void AudioWriteToReg(unsigned char u8RegAddr, unsigned char u8Data) {

	unsigned char u8TxData[3];

	u8TxData[0] = 0x40;
	u8TxData[1] = u8RegAddr;
	u8TxData[2] = u8Data;

	XIicPs_MasterSendPolled(&Iic, u8TxData, 3, (IIC_SLAVE_ADDR >> 1));
	while(XIicPs_BusIsBusy(&Iic));
}

/******************************************************************************
 * Configures audio codes's various mixers, ADC's, DAC's, and amplifiers to
 * accept stereo input from line in and push stereo output to line out
 *
 * @param	none.
 *
 * @return	none.
 *****************************************************************************/

void AudioConfigureJacks()
{
	AudioWriteToReg(R4_RECORD_MIXER_LEFT_CONTROL_0, 0x01); //enable mixer 1
	AudioWriteToReg(R5_RECORD_MIXER_LEFT_CONTROL_1, 0x07); //unmute Left channel of line in into mxr 1 and set gain to 6 db
	AudioWriteToReg(R6_RECORD_MIXER_RIGHT_CONTROL_0, 0x01); //enable mixer 2
	AudioWriteToReg(R7_RECORD_MIXER_RIGHT_CONTROL_1, 0x07); //unmute Right channel of line in into mxr 2 and set gain to 6 db
	AudioWriteToReg(R19_ADC_CONTROL, 0x13); //enable ADCs

	AudioWriteToReg(R22_PLAYBACK_MIXER_LEFT_CONTROL_0, 0x21); //unmute Left DAC into Mxr 3; enable mxr 3
	AudioWriteToReg(R24_PLAYBACK_MIXER_RIGHT_CONTROL_0, 0x41); //unmute Right DAC into Mxr4; enable mxr 4
	AudioWriteToReg(R26_PLAYBACK_LR_MIXER_LEFT_LINE_OUTPUT_CONTROL, 0x05); //unmute Mxr3 into Mxr5 and set gain to 6db; enable mxr 5
	AudioWriteToReg(R27_PLAYBACK_LR_MIXER_RIGHT_LINE_OUTPUT_CONTROL, 0x11); //unmute Mxr4 into Mxr6 and set gain to 6db; enable mxr 6
	AudioWriteToReg(R29_PLAYBACK_HEADPHONE_LEFT_VOLUME_CONTROL, 0x00);//Mute Left channel of HP port (LHP)
	AudioWriteToReg(R30_PLAYBACK_HEADPHONE_RIGHT_VOLUME_CONTROL, 0x00); //Mute Right channel of HP port (LHP)
	AudioWriteToReg(R31_PLAYBACK_LINE_OUTPUT_LEFT_VOLUME_CONTROL, 0xE6); //set LOUT volume (0db); unmute left channel of Line out port; set Line out port to line out mode
	AudioWriteToReg(R32_PLAYBACK_LINE_OUTPUT_RIGHT_VOLUME_CONTROL, 0xE6); // set ROUT volume (0db); unmute right channel of Line out port; set Line out port to line out mode

	AudioWriteToReg(R35_PLAYBACK_POWER_MANAGEMENT, 0x03); //enable left and right channel playback (not sure exactly what this does...)
	AudioWriteToReg(R36_DAC_CONTROL_0, 0x03); //enable both DACs

	AudioWriteToReg(R58_SERIAL_INPUT_ROUTE_CONTROL, 0x01); //Connect I2S serial port output (SDATA_O) to DACs
	AudioWriteToReg(R59_SERIAL_OUTPUT_ROUTE_CONTROL, 0x01); //connect I2S serial port input (SDATA_I) to ADCs

	AudioWriteToReg(R65_CLOCK_ENABLE_0, 0x7F); //Enable clocks
	AudioWriteToReg(R66_CLOCK_ENABLE_1, 0x03); //Enable rest of clocks
}

/******************************************************************************
 * Configures Line-In input, ADC's, DAC's, Line-Out and HP-Out.
 *
 * @param   none.
 *
 * @return	none.
 *****************************************************************************/
void LineinLineoutConfig() {

	AudioWriteToReg(R17_CONVERTER_CONTROL_0, 0x06);//96 kHz
	AudioWriteToReg(R64_SERIAL_PORT_SAMPLING_RATE, 0x06);//96 kHz
	AudioWriteToReg(R19_ADC_CONTROL, 0x13);
	AudioWriteToReg(R36_DAC_CONTROL_0, 0x03);
	AudioWriteToReg(R35_PLAYBACK_POWER_MANAGEMENT, 0x03);
	AudioWriteToReg(R58_SERIAL_INPUT_ROUTE_CONTROL, 0x01);
	AudioWriteToReg(R59_SERIAL_OUTPUT_ROUTE_CONTROL, 0x01);
	AudioWriteToReg(R65_CLOCK_ENABLE_0, 0x7F);
	AudioWriteToReg(R66_CLOCK_ENABLE_1, 0x03);

	AudioWriteToReg(R4_RECORD_MIXER_LEFT_CONTROL_0, 0x01);
	AudioWriteToReg(R5_RECORD_MIXER_LEFT_CONTROL_1, 0x05);//0 dB gain
	AudioWriteToReg(R6_RECORD_MIXER_RIGHT_CONTROL_0, 0x01);
	AudioWriteToReg(R7_RECORD_MIXER_RIGHT_CONTROL_1, 0x05);//0 dB gain

	AudioWriteToReg(R22_PLAYBACK_MIXER_LEFT_CONTROL_0, 0x21);
	AudioWriteToReg(R24_PLAYBACK_MIXER_RIGHT_CONTROL_0, 0x41);
	AudioWriteToReg(R26_PLAYBACK_LR_MIXER_LEFT_LINE_OUTPUT_CONTROL, 0x03);//0 dB
	AudioWriteToReg(R27_PLAYBACK_LR_MIXER_RIGHT_LINE_OUTPUT_CONTROL, 0x09);//0 dB
	AudioWriteToReg(R29_PLAYBACK_HEADPHONE_LEFT_VOLUME_CONTROL, 0xE7);//0 dB
	AudioWriteToReg(R30_PLAYBACK_HEADPHONE_RIGHT_VOLUME_CONTROL, 0xE7);//0 dB
	AudioWriteToReg(R31_PLAYBACK_LINE_OUTPUT_LEFT_VOLUME_CONTROL, 0x00);//0 dB
	AudioWriteToReg(R32_PLAYBACK_LINE_OUTPUT_RIGHT_VOLUME_CONTROL, 0x00);//0 dB
}
